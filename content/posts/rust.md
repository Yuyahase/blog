---
title: "Rustの所有権"
date: 2022-03-29T22:58:01+09:00
tags: ["Rust"] 
author: "Me"
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowCodeCopyButtons: true
---

## 所有権

Rustではメモリは、コンパイラがコンパイル時にチェックする一定の規則とおもに所有権システムを通じてチェックされる。

## スタックとヒープ

Rustでは値がスタックに積まれるか、ヒープに置かれるか判別することは重要。

### スタック

- 得た順番で並べ、逆の順で値を取り出す(last in, first out)
- データを追加することをpushといい、取り除くことをpopと表現する。
- データを探す必要がないので高速。
- スタック上のデータは全て既知の固定サイズでなければいけない。
- コンパイラやOSが自動的に割り当て、解放を行う。

### ヒープ

- 順序関係なしにメモリ確保、解除ができる。
- ヒープのデータアクセスは、スタックよりも低速。
- サイズが可変のデータについては、ヒープに格納する。
- いつヒープ領域を解放するかが問題
  - 手動で解放(C言語)
  - 使われなくなったメモリ領域を自動で解放(Java)
- メモリ管理が不適切だとヒープ領域を使い切ってしまい、メモリーリークが起きたり、無効なメモリ領域を指すダングリングポインタ(dangling pointer)が起きたりする。

## 所有権規則

- 各値は、所有者と呼ばれる変数に対応している。
- いかなる時も所有者は一つである。
- 所有者がスコープから外れたら、値は破棄される。

```rust
fn main() {
   {
       let a = String::from("hello");
   }
   // ここで a にはアクセス不能に。
   // a の持っていた値は解放される

   println!("{}", a);   // コンパイルエラー
}
```

```rust
fn main() {
   let s1 = String::from("hello");
   let s2 = s1;

   println!("{}, world!", s1); 
   // error[E0382]: borrow of moved value: `s1`
}
```
