---
title: "Rustの所有権"
date: 2022-03-29T22:58:01+09:00
tags: ["Rust"] 
author: "Me"
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowCodeCopyButtons: true
---

## 所有権

変数に値を束縛すると、変数はその値の所有者となる。
`=`を使うと、右オペランドの変数が持っていた所有権が、左オペランドに移る。

## スタックとヒープ

Rustでは値がスタックに積まれるか、ヒープに置かれるか判別することは重要。

### スタック

- 得た順番で並べ、逆の順で値を取り出す(last in, first out)
- データを追加することをpushといい、取り除くことをpopと表現する。
- データを探す必要がないので高速。
- スタック上のデータは全て既知の固定サイズでなければいけない。
- コンパイラやOSが自動的に割り当て、解放を行う。

### ヒープ

- 順序関係なしにメモリ確保、解除ができる。
- ヒープのデータアクセスは、スタックよりも低速。
- サイズが可変のデータについては、ヒープに格納する。
- いつヒープ領域を解放するかが問題
  - 手動で解放(C言語)
  - 使われなくなったメモリ領域を自動で解放(Java)
- メモリ管理が不適切だとヒープ領域を使い切ってしまい、メモリーリークが起きたり、無効なメモリ領域を指すダングリングポインタ(dangling pointer)が起きたりする。

## 所有権規則

- 各値は、所有者と呼ばれる変数に対応している。
- いかなる時も所有者は一つである。
- 所有者がスコープから外れたら、値は破棄される。

```rust
fn main() {
   {
       let a = String::from("hello");
   }
   // ここで a にはアクセス不能に。
   // a の持っていた値は解放される

   println!("{}", a);   // コンパイルエラー
}
```

所有権を失った変数を使おうとすると、コンパイルエラーになる。

```rust
fn main() {
   let s1 = String::from("hello");
   let s2 = s1;

   println!("{}, world!", s1); 
   // error[E0382]: borrow of moved value: `s1`
}
```

所有権の移転ではなく値をコピーしたいときは、`cloneメソッド`を使う。

```rust

fn main() {
   let _x = "foo".to_string();
   let _y = _x.clone();
   let _z = _x;
}
```

## 借用

所有権を保持したまま、値を参照する権利だけを他の変数に貸すことができる。

値を参照するには`&`を用いる

```rust

fn main() {
   let x = "foo".to_string();
   let y = &x; // yはxが持っている"foo"を参照しているだけ
   let z = x;  // ここで所有権の移転が起きる
}
```
